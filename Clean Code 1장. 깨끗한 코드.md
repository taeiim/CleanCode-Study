# Clean Code 1장. 깨끗한 코드

> 이 책을 읽고 있다면 이유는 두가지다.
>
> 첫째, 프로그래머라서,
>
> 둘째, 더 나은 프로그래머가 되려고 ! 



> 이 책을 읽고나면  좋은 코드와 나쁜 코드를 구분하는 능력도 생긴다.
>
> 게다가 좋은 코드를 작성하는 방법도 익힌다.
>
> 마지막으로 나쁜 코드를 좋은 코드로 바꾸는 실력도 쌓인다. 



나는 더 나은 프로그래머가 되기 위해, 좋은 코드를 작성하기 위해 이 책을 읽기 시작했다. 



</br></br>



## 나쁜 코드

### 르블랑의 법칙 

> 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다. 
>
> 다시 돌아와 나중에 정리하겠다고 다짐했었다.
>
> 하지만 나중은 결코 오지 않는다. 



읽으면서 굉장히 공감이 된 내용이다.  업무가 밀려서, 코드를 다듬을 시간이 없어서, 제대로 짤 시간이 없다고 생각해서 

나쁜 코드를 보고도 심지어 나쁜 코드를 만들어 내고 있음을 알고도 `ㅇr.. 나중에 고치자..! 지금은 시간이 없어..` 라 생각하며 넘긴다. 

하지만 나중은 결코 돌아오지 않는다.

그것이 바로 르블랑의 법칙이다.  (미루지말고 지금 잘하자 !^^ㅎㅎㅜㅜ)

<br>

### 나쁜 코드로 치루는 대가

> 회사가 망한 원인은 바로 나쁜 코드 탓이었다.

나쁜 코드는 개발 속도를 크게 떨어뜨린다. 코드를 고칠 때마다 엉뚱한 곳에서 문제가 생긴다. 간단한 변경은 없다. 

실제로 한줄만 고치면 되겠지! 하고 생각했던 업무가 수십개의 모듈,클래스를 건들여야 하는 일인 경우가 너무 많았다. 1시간이면 된다고 생각했던 게 몇일,몇주로 늘어졌던 경험도 있다. (ㅋㅋㅋㅋㅋㅠㅠㅠㅠㅠㅠ)

나쁜 코드는 **시간이 지날수록 팀의 생산성을 떨어뜨린다**

</br>

### 프로그래머의 태도

> 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 것은 전문가답지 못한 행동이다. 

**좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다.**

비유를 하나 들겠다. 자신이 의사라 가정하자. 어느 환자가 수술 전에 손을 씻지 말라고 요구한다. 시간이 너무 걸리니까. 확실히 환자는 상사다. 하지만 의사는 단호하게 거부한다. 왜? 질병과 감염의 위험은 환자보다 의사가 더 잘 아니까. 환자 말을 그대로 따르는 행동은 (범죄일 뿐만 아니라) 전문가 답지 못하니까. 

프로그래머도 마찬가지다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.

</br>

### 좋은 코드와 개발속도

대부분 프로그래머라면 누구나 나쁜 코드가 업무 속도를 늦춘다는 사실을 잘 안다. 그럼에도 기한을 맞추려면 나쁜 코드를 양산할 수밖에 없다고 느낀다. 간단히 말해, `그들은 빨리 가려고 시간을 들이지 않는다.`

`진짜 전문가` 는 오히려 엉망진창인 상태로 인해 속도가 늦어질 거라는 것을 안다. 

빨리가는 유일한 방법은, **언제나 코드를 최대한 깨끗하게 유지하는 습관**이다. 



</br></br>



## 깨끗한 코드

그렇다면 깨끗한 코드란 무엇이고, 어떻게 작성할까

</br>

### 깨끗한 코드란?

> 장인들이 말하는 깨끗한 코드의 정의 

- 보기에 즐거운(우아한) 코드
- 철저한 오류처리 (메모리 누수, 경쟁상태, 일관성 없는 명명법) - 세세한 사항까지 꼼꼼하게 처리하는 코드
- 한 가지에 '집중' (각 함수, 클래스와 모듈은 한가지에만 집중)
- 가독성이 좋은 코드 (잘 쓴 문장처럼 읽혀야 함)
- 코드는 추측이 아니라 사실에 기반. 반드시 필요한 내용만 담아야함.
- 다른 사람이 고치기 쉬운 코드
- 테스트 케이스가 존재
- 모든 테스트를 통과한다.
- 주의 깊게 작성한 코드 (시간을 들여 깔끔하고 단정하게 정리한 코드)
- 중복이 없다.
- 시스템 내 모든 설계 아이디어를 표현
- 클래스, 메서드 ,함수 등을 최대한 줄인다.
- 짐작하는 기능을 그대로 수행하는 코드

</br>

####깨끗한 코드의 필요성

> 급하다면, 서둘러 끝내려면, 쉽게 짜려면, 읽기 쉽게 만들면 된다.

열심히 작업한 후 편집 세션을 재생해보면 대부분이 화면을 스크롤하거나 다른 모듈을 찾아보는 동작이었다. 
코드를 읽는 시간 : 코드를 짜는 시간 = 10 : 1  을 훌쩍 넘는다. 

새로운 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다. 기존 코드를 읽어야 새 코드를 짜므로 읽기 쉽게 만들면 짜기도 쉬워진다.  주변 코드가 어려우면 새 코드를 짜기도 어렵다.  기존 코드가 깨끗하다면 새코드를 짜기도 쉬워진다.

</br>

#### 보이스카우트 규칙

시간이 지나도 언제나 깨끗한 코드를 유지해야 한다.

체크아웃할 때보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다.

</br>

#### 객체지향 설계의 5대원칙 : SOLID

1. SRP (단일 책임의 원칙 : Single Responsibility Principle)

   클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다.

2. OCP (개방 폐쇄의 원칙 : Open Closed Principle)

   클래스는 확장에 열려 있어야 하며 변경에 닫혀 있어야 한다.

3. LSP (리스코브 치환의 원칙 : Liskov Subsitution Principle)

   상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다.

4. DIP (의존성 역전의 원칙 : Dependency Inversion Principle)

   추상화에 의존해야 하며, 구체화에 의존하면 안 된다.

5. ISP (인터페이스 분리의 원칙 : Interface Segregation Principle)

   클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다.



</br></br>



## 마무리

'깨끗한 코드는 무엇일까?' 라는 생각을 깊게 해본 적이 없는데 책을 읽으며 깨끗한 코드는 무엇인가에 대한 생각을 해 나갈수 있는 기회가 되었다. 나쁜 코드의 엄청난 위험성과 깨끗한 코드의 필요성을 크게 느낄 수 있던 1장이었다. 

클-린 코드가 왜 필요한지 알았으니, 이제 부터는 어떻게 짜야, 구체적으로 어떤 것이 클린코드인지 더 궁금해졌다. (꼭 완독해야징)



